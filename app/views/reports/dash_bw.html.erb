<%
  #
  # Get all the database records in go!
  #
  @IpStatRecs= Ipstat.select("strftime('%Y-%m-%d %H', timestamp) as time, 
                                destip as ip, deviceid as device, 
                                sum(inbytes) as inbytes, sum(outbytes) as outbytes").
                      # where("timestamp >= ?", 1.day.ago.strftime("%Y-%m-%d %H:%M:%S")).
                      where("timestamp >= ?", "2013-02-01").
                      group(:time, :destip, :deviceid).order(:destip)
# Total (IN + OUTbytes) consumption per Server, per hour
# Key: Internal_Server_IP_address, Value: 24 element 'integer' array holding Mbytes consumed/hr.
hash24HrData = Hash.new

#
# Per Server, Total INbytes and OUTBytes.
# Key: Internal_Server_IP_address, Value: Array[INbytes, OUTbytes]
hashServerTotals = Hash.new

#
# Per Device, Total INbytes and OUTbytes
# Key: Mobile Device MAC id, Value: Array[INbytes, OUTbytes]
hashDeviceTotals = Hash.new

#
#Per Server, Per Port, hourly data of INbytes, OUTbytes
# Key: Internal_Server_IP_address, Value: Hash {Port => Array[INbytes, OUTbytes]}
hashServerPortTotals = Hash.new 

@IpStatRecs.each do |rec |

  arrayhourlyData = hash24HrData[rec['ip']]
  if arrayhourlyData.nil? then
     arrayhourlyData = hash24HrData[rec['ip']] = Array.new(24, 0)
  end

  recTime = rec['time'].split[1].to_i
  arrayhourlyData[recTime] += (rec['inbytes'] + rec['outbytes'])

  arrayServerTotal = hashServerTotals[rec['ip']]
  if arrayServerTotal.nil? then
     arrayServerTotal = hashServerTotals[rec['ip']] = Array.new(2, 0)
  end
  arrayServerTotal[0] += rec['inbytes']
  arrayServerTotal[1] += rec['outbytes']

  arrayDeviceTotal = hashDeviceTotals[rec['device']]
  if arrayDeviceTotal.nil? then
     arrayDeviceTotal = hashDeviceTotals[rec['device']] = Array.new(2, 0)
  end
  arrayDeviceTotal[0] += rec['outbytes']  # for devices, OUT becomes IN and vice versa
  arrayDeviceTotal[1] += rec['inbytes']

end

# Selecting the top 10 servers to display in the bandwidth line graph
hashGraphTimeBasedTotals = Hash[hash24HrData.sort_by {|key, value| value.reduce(:+)}.reverse[0..10]]

currentTime = Time.now.strftime("%H").to_i 
hashGraphTimeBasedTotals.each do |i, arrayTotals|
  arrayTotals.rotate!(currentTime+1)
end

# Servers (sorted in descending order of Total bytes) for the dataTable
hashServers = Hash[hashServerTotals.sort_by {|key, value| value.reduce(:+)}.reverse]
# Devices (sorted in descending order of Total bytes) for the dataTable
hashDevices = Hash[hashDeviceTotals.sort_by {|key, value| value.reduce(:+)}.reverse]
%>

<!-- content starts -->
<div id="content" class="span10">
   <div class="row-fluid sortable">		
      <div class="box span12">
         <%= render :partial => 'layouts/title_bar_icons',
                    :locals => { :header_title => "Bandwidth Consumption (Past 24 Hours)",
                                 :header_link  => "#" }
         %>
         <div class="box-content">
            <canvas id="total_bw" width="900" height="300">[No canvas support]</canvas>
         </div>
      </div> <!-- box span12 -->
   </div><!-- row-fluid sortable -->

   <div class="row-fluid sorttable">
      <div class="box span6">
         <%= render :partial => 'layouts/title_bar_icons',
                    :locals => { :header_title => "Top Servers",
                                 :header_link  => "#" }
         %>
         <div class="box-content">
            <table class="table table-striped table-bordered bootstrap-datatable datatable">
               <thead>
	          <tr>
	             <th>Server</th>
		     <th>Incoming (Mbytes) </th>
                     <th>Outgoing (Mbytes)</th>
                     <th>Total (MBytes)</th>
	          </tr>
	       </thead>   
	       <tbody>
               <% hashServers.each do | server_ip, arrayTotals | %>
                     <tr>
                        <td><%= link_to server_ip, :action => "dash_bw_server", :server_ip => server_ip %></td>
                        <td><%= arrayTotals[0] %></td>
                        <td><%= arrayTotals[1] %></td>
                        <td><%= arrayTotals.reduce(:+) %></td>
                     </tr>
               <% end %>
               
               </tbody>
            </table>
         </div> <!-- box-content -->
      </div> <!-- box span6 -->

      <div class="box span6">
         <%= render :partial => 'layouts/title_bar_icons',
                    :locals => { :header_title => "Top Devices",
                                 :header_link  => "#" }
         %>
         <div class="box-content">
            <table class="table table-striped table-bordered bootstrap-datatable datatable">
               <thead>
	                <tr>
	                   <th>Device</th>
		                 <th>Incoming (Mbytes) </th>
                     <th>Outgoing (Mbytes)</th>
                     <th>Total (MBytes)</th>
	                </tr>
	             </thead>   
	             <tbody>
               <% hashDevices.each do | device, arrayTotals | %>                     
                  <tr>
                     <td><%= device %></td>
                     <td><%= arrayTotals[0] %></td>
                     <td><%= arrayTotals[1] %></td>
                     <td><%= arrayTotals.reduce(:+) %></td>
                  </tr>
               <% end %>
               </tbody>
            </table>
            </div> <!-- box-content -->
         </div> <!-- box span6 -->
   </div><!-- row-fluid sortable -->
</div><!-- content ends -->


<script type="text/javascript">
        window.onload = function ()
        {
            var myLine = new RGraph.Line('total_bw', <%= hashGraphTimeBasedTotals.values %>);
            myLine.Set('chart.labels', <%=raw graphLabels24Hrs.map { |i| i.to_s } %>);

            myLine.Set('chart.key', <%=raw hashGraphTimeBasedTotals.keys %>);
            myLine.Set('chart.key.color.shape', 'circle');
            myLine.Set('chart.key.position', 'graph');

            myLine.Set('chart.linewidth', 5);
            myLine.Set('chart.background.grid.autofit.numvlines', 24);
            myLine.Set('chart.background.grid.autofit.numhlines', 20);

            myLine.Set('chart.colors', ['red', 'black','#DDDF0D','#7798BF', '#ABD874', '#E18D87', '#599FD9', '#F4AD7C', '#D5BBE5']);
            myLine.Set('chart.text.color', '#333');
            myLine.Set('chart.text.font', 'Arial');
            myLine.Set('chart.background.grid.autofit', true);
            myLine.Set('chart.shadow', true);
            myLine.Set('chart.shadow.color', 'rgba(20,20,20,0.3)');
            myLine.Set('chart.shadow.blur',  10);
            myLine.Set('chart.shadow.offsetx', 0);
            myLine.Set('chart.shadow.offsety', 0);
            myLine.Set('chart.background.grid.border', true);
            myLine.Set('chart.axis.color', '#666');
            myLine.Set('chart.text.color', '#666');
            myLine.Set('chart.key.interactive', true);
            myLine.Set('chart.spline', true);
            myLine.Set('chart.title', 'Bandwidth (Mbytes)');
            //myLine.Set('chart.tickmarks', 'circle');


            /**
            * Use the Trace animation to show the chart
            */
            if (RGraph.isOld()) {
                // IE7/8 don't support shadow blur, so set custom shadow properties
                myLine.Set('chart.shadow.offsetx', 3);
                myLine.Set('chart.shadow.offsety', 3);
                myLine.Set('chart.shadow.color', '#aaa');
                myLine.Draw();
            } else {
                RGraph.Effects.Line.jQuery.UnfoldFromCenterTrace(myLine, {'duration': 1000});
            }
        }
</script>

